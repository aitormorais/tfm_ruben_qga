importos
importnumpyasnp
importquantum_matsasqm
fromcopyimportdeepcopy
importtime
importre

definitialize_population(init_population,n,cl,track_fidelity,store_path,generation_number):
#Códigoquemanejalainicializacióndelapoblaciónyloserroresrelacionados
ifinit_populationisNone:
#generatearandompopulation
raiseValueError('init_populationisrequiredinthisversion.Randompopulationisnotsupported.')
eliftype(init_population)==qm.rho:
ifnotnornotcl:
raiseValueError('Ifpopulationisaquantum_matrix.rhoobjectnandclarerequired.')
a=n//2
ancillas=[iaforiainrange(n*cl,n*cl+a)]
ancillas_initial_state=np.zeros((2**a,2**a))
ancillas_initial_state[0,0]=1
rho_pop=qm.rho(np.kron(init_population.get_matrix(),ancillas_initial_state),dense=True)
else:
population=deepcopy(init_population)
ifn!=len(population)orcl!=len(population[0]):
raiseValueError('nandclmismatch.{}!={}or{}!={}.'.format(n,len(population),cl,len(population[0])))
i=0
index=0
forpinpopulation:
forcinp:
i+=c*2**(n*cl-index-1)
index+=1
a=n//2
ancillas=[iaforiainrange(n*cl,n*cl+a)]
rho_pop=qm.rho([1],[i*2**a],[i*2**a],(2**(n*cl+a),2**(n*cl+a)))

iftrack_fidelity:
fidelity_array=np.zeros(shape=(generation_number,5,n,len(track_fidelity)))

ifstore_path:
store=open(store_path,'w')
print('GeneticAlgorithmparameters:',file=store)
print('generation_numbar={:d},pm={:f},populationnumber={:d},chromosomelength={:d}'.format(
generation_number,pm,n,cl),file=store)
print('Trackedfidelityforstates:',file=store)
iftrack_fidelity:
forstateintrack_fidelity:
iftype(state)==qm.rho:
print(state.get_matrix(),file=store)
else:
print(repr(state),file=store)
else:
print("None",file=store)
print(file=store)
returnrho_pop

defcloning_routine_unitary(n,cl,a):
clone=qm.Identity(2**(n*cl))
fornuinrange(0,n//2):
s=qm.Swap_reg(range((nu+1)*cl,(nu+2)*cl),
range((nu+n//2)*cl,(nu+1+n//2)*cl),
n*cl)
u=qm.Uclone(2**cl)
unu=s.dot(qm.KronExpand(2**(nu*cl),u,2**((n-nu-2)*cl))).dot(s)
clone=clone.dot(unu)
clone=qm.KronExpand(1,clone,2**a)
returnclone.get_matrix()

defcrossover_rutine_unitary(n,cl,a):
#Buildthecrossoverroutineunitary
cross_index=cl//2
qq1=np.array([q1fornuinrange(0,n//2,2)forq1inrange((n//2+nu)*cl+cross_index,(n//2+nu+1)*cl)])
qq2=np.array([q2fornuinrange(0,n//2,2)forq2inrange((n//2+nu+1)*cl+cross_index,(n//2+nu+2)*cl)])
cross=qm.Swap_reg(qq1,qq2,n*cl)
cross=qm.KronExpand(1,cross,2**a)
returncross.get_matrix()

defsor_semisort_unitary_og(n,cl,a,fitness_basis,fitness_criteria):
sort_arr=[np.identity(2**(n*cl+a)),np.identity(2**(n*cl+a))]
forstagein[0,1]:
forreginrange(0,n-1,2):
nu=reg+stage%2
ifnu+2>n:
continue
reg1=list(range(nu*cl,(nu+1)*cl))
reg2=list(range((nu+1)*cl,(nu+2)*cl))
ancilla=n*cl+reg//2
orac=qm.Oracle.get_qf_sort_oracle(nq=n*cl+a,
reg1=reg1,
reg2=reg2,
ancilla=ancilla,
uu=fitness_basis,
criteria=fitness_criteria)
cs=qm.CSwap_reg(ancilla,
reg1,
reg2,
n*cl+a).get_matrix()
sort_arr[stage]=sort_arr[stage].dot(cs).dot(orac)
sort0,sort1=sort_arr
mat_sort0=sort0
mat_sort1=sort1
returnmat_sort0,mat_sort1
defsort_semisort_unitary(n,cl,a,fitness_basis,fitness_criteria):
sort_arr=[np.identity(2**(n*cl+a)),np.identity(2**(n*cl+a))]
forstagein[0,1]:
forreginrange(0,n-1,2):
nu=reg+stage%2
ifnu+2>n:
continue
reg1=list(range(nu*cl,(nu+1)*cl))
reg2=list(range((nu+1)*cl,(nu+2)*cl))
ancilla=n*cl+reg//2
orac=qm.Oracle.get_qf_sort_oracle(nq=n*cl+a,
reg1=reg1,
reg2=reg2,
ancilla=ancilla,
uu=fitness_basis,
criteria=fitness_criteria)
cs=qm.CSwap_reg(ancilla,
reg1,
reg2,
n*cl+a).get_matrix()
sort_arr[stage]=sort_arr[stage].dot(cs).dot(orac)
sort0,sort1=sort_arr
returnsort0,sort1


defvalidate_mutation_unitary(mutation_unitary):
ifre.match(r"^[rR]$",mutation_unitary):
returnTrue
elifre.match(r"^(?:[xX]|not|NOT)$",mutation_unitary):
returnTrue
elifre.match(r"^[hH]$",mutation_unitary):
returnTrue
elifre.match(r"^[iI]$",mutation_unitary):
returnTrue
returnFalse

defcreate_mutation_unitary(mutation_unitary):
ifre.match(r"^[rR]$",mutation_unitary):
returnqm.rho(mutation_unitary,dense=True)
elifre.match(r"^(?:[xX]|not|NOT)$",mutation_unitary):
returnqm.rho([1,1],[0,1],[1,0],(2,2))
elifre.match(r"^[hH]$",mutation_unitary):
returnqm.rho(np.array([1,1,1,-1])/np.sqrt(2),[0,0,1,1],[0,1,0,1],(2,2))
elifre.match(r"^[iI]$",mutation_unitary):
returnqm.Identity(2)
raiseValueError("mutation_unitary=\"%s\"notrecognised."%mutation_unitary)


defbuild_unitary_routines(n,cl,fitness_basis,fitness_criteria,a):
#Códigoparaconstruirlasrutinasunitarias
#Builddecloningroutineunitary
mat_clone=cloning_routine_unitary(n,cl,a)
#Buildthecrossoverroutineunitary
mat_cross=crossover_rutine_unitary(n,cl,a)

#Buildthesort/semisortstepunitary
#Youcantbuilditcompletelybecauseyouneedtosettheancillasto
#zeroineachstage,butthismakesiteasierlater.
mat_sort0,mat_sort1=sort_semisort_unitary(n,cl,a,fitness_basis,fitness_criteria)

returnmat_clone,mat_cross,mat_sort0,mat_sort1

defbuild_mutation_arrays(mutation_unitary,pm,n,cl,mutation_pattern):
#Códigoparaconstruirlosarreglosdemutación
#Buildmutationarrays
mut_arr=[]
mat_mut_arr=[]
iftype(mutation_unitary)==listortype(pm)==list:
iftype(mutation_unitary)!=listortype(pm)!=list:
raiseValueError("mutation_unitaryandpmarenotconsistent.")
iflen(mutation_unitary)!=len(pm):
raiseValueError("Thelengthofmutation_unitaryandpmisnotconsistent.")
ifsum(pm)>=1:
raiseValueError("Mutationprobabilitiesmustadduptolessthanone.")
ifnot(mutation_patternisNone):
raiseValueError("Usingmutation_patternandasetofmutationunitariesisnotcompatible.")
use_mutation_unitary_set=True
pm_sum=sum(pm)
pm_norm=[pmi/pm_sumforpmiinpm]
else:
pm_sum=pm
use_mutation_unitary_set=False

ifnotuse_mutation_unitary_set:
ifmutation_unitarynotin["r","R"]:
iftype(mutation_unitary)==str:
ifmutation_unitaryin["x","X","not","NOT"]:
mutation_unitary=qm.rho([1,1],[0,1],[1,0],(2,2))
elifmutation_unitaryin["h","H"]:
mutation_unitary=qm.rho(np.array([1,1,1,-1])/np.sqrt(2),[0,0,1,1],[0,1,0,1],(2,2))
elifmutation_unitaryin["i","I"]:
mutation_unitary=qm.Identity(2)
else:
raiseValueError("mutation_unitary=\"%s\"notrecognised."%mutation_unitary)
else:
mutation_unitary=qm.rho(mutation_unitary,dense=True)

#mut_arr=[]
#mat_mut_arr=[]
foriinrange(n*cl):
mut_arr.append(qm.KronExpand(2**i,mutation_unitary,2**(n*cl-i-1+a)))
mat_mut_arr.append(np.kron(np.kron(np.identity(2**i),
mutation_unitary.get_matrix()),
np.identity(2**(n*cl-i-1+a))))
returnuse_mutation_unitary_set,pm_sum,pm_norm,mut_arr,mat_mut_arr

defbuild_pre_projection_rotation(pre_projection_unitary,n,cl,a):
"""
Buildthepre-projectionrotationmatrix.

:parampre_projection_unitary:stringorunitarymatrixforpre-projection
:paramn:numberofqubits
:paramcl:controllines
:parama:ancillaryqubits
:return:pre-projectionrotationmatrix
"""
#Códigoparaconstruirlarotaciónpreviaalaproyección
#Buildthepre-projectionrotation
lower_rot_mat=np.identity(2**(n//2*cl))
forlreginrange(n-n//2):
lower_rot_mat=np.kron(lower_rot_mat,pre_projection_unitary)
lower_rot_mat=np.kron(lower_rot_mat,np.identity(2**a))

lower_rot=None#Notimplemented
returnlower_rot_mat

defquantum_genetic_algorithm(init_population,n,cl,generation_number,pm,fitness_basis,fitness_criteria,mutation_unitary,pre_projection_unitary,store_path,track_fidelity):
rho_pop,fidelity_array,store=initialize_population(init_population,n,cl,track_fidelity,store_path)
mat_clone,mat_cross,sort0,sort1=build_unitary_routines(n,cl,fitness_basis,fitness_criteria)
use_mutation_unitary_set,pm_sum,pm_norm,mut_arr,mat_mut_arr=build_mutation_arrays(mutation_unitary,pm,n,cl,mutation_pattern)
lower_rot_mat,lower_rot=build_pre_projection_rotation(pre_projection_unitary,n,cl)

#Códigoparaelbucleprincipaldegeneracionesyotrasoperaciones

definit_rho_pop_from_array(init_population,n,cl):
population=np.array(deepcopy(init_population))
ifn!=len(population)orcl!=len(population[0]):
raiseValueError('nandclmismatch.{}!={}or{}!={}.'.format(n,len(population),cl,len(population[0])))

i=0
index=0
forpinpopulation:
forcinp:
i+=c*2**(n*cl-index-1)
index+=1

a=n//2
ancillas=[iaforiainrange(n*cl,n*cl+a)]
rho_pop=qm.rho([1],[i*2**a],[i*2**a],(2**(n*cl+a),2**(n*cl+a)))
returnrho_pop,ancillas,a

definit_rho_pop_from_rho(init_population,n,cl):
a=n//2
ancillas=[iaforiainrange(n*cl,n*cl+a)]
ancillas_initial_state=np.zeros((2**a,2**a))
ancillas_initial_state[0,0]=1
rho_pop=qm.rho(np.kron(init_population.get_matrix(),ancillas_initial_state),dense=True)
returnrho_pop,ancillas,a

definit_pop_numpy(init_population,n,cl,generation_number):
#Códigoquemanejalainicializacióndelapoblaciónyloserroresrelacionados
ifinit_populationisNone:
#generatearandompopulation
raiseValueError('init_populationisrequiredinthisversion.Randompopulationisnotsupported.')
eliftype(init_population)==qm.rho:
ifnotnornotcl:
raiseValueError('Ifpopulationisaquantum_matrix.rhoobjectnandclarerequired.')
rho_pop,ancillas,a=init_rho_pop_from_rho(init_population,n,cl)
else:
rho_pop,ancillas,a=init_rho_pop_from_array(init_population,n,cl)
returnrho_pop,ancillas,a


defapply_mutation(rho_pop,n,cl,a,pm_sum,pm_norm,mutation_unitary,pm):
"""
Aplicaunamutaciónalapoblaciónconunaprobabilidaddada.

:paramrho_pop:Poblaciónactual
:paramn:Númerodequbits
:paramcl:Númerodecromosomas
:parama:Cantidadaagregaralexponentedelamatrizdeidentidad
:parampm_sum:Probabilidadtotaldemutación
:parampm_norm:Probabilidadesnormalizadasparacadamutación
:parammutation_unitary:Matricesunitariasdemutación
:return:Poblaciónmutada
"""
forcinrange(n*cl):
r=np.random.random()
ifr<pm_sum:
mu=mutation_unitary[np.random.choice(range(len(pm)),p=pm_norm)]
mut_mat=np.kron(np.kron(np.identity(2**c),mu),
np.identity(2**(n*cl-c-1+a)))
rho_pop=qm.rho(mut_mat.dot(rho_pop.get_matrix().dot(np.transpose(mut_mat).conjugate())),
dense=True)
returnrho_pop
defapply_projection(rho_pop,n,cl,a,projection_method,pre_projection_unitary):
"""
Aplicalaproyeccióndeseadaalapoblación.

:paramrho_pop:Poblaciónactual
:paramn:Númerodequbits
:paramcl:Númerodecromosomas
:parama:Cantidadaagregaralexponentedelamatrizdeidentidad
:paramprojection_method:Métododeproyecciónautilizar
:parampre_projection_unitary:Matrizunitariaaaplicarantesdelaproyección
:return:Poblacióndespuésdelaproyección
"""
ifprojection_method!='ptrace':
forqinrange(n//2*cl,n*cl):
rho_pop.projection_controlled_rotation(q,1,qm.rho([1,1],[0,1],[1,0],(2,2)),
pre_projection_unitary,projection_method)
else:
iftype(pre_projection_unitary)!=str:
rho_pop=qm.rho(lower_rot_mat.dot(rho_pop.get_matrix()).dot(np.transpose(np.conjugate(lower_rot_mat))),dense=True)
elifpre_projection_unitary!="I":
raiseException("Only\"I\"pre_projection_unitaryissupportedwithtypestr")

rho_pop=rho_pop.partial_trace(list(range(n//2*cl)))
rho_pop=qm.rho(np.kron(rho_pop.get_matrix(),
qm.rho([1],[0],[0],
(2**(n*cl-n//2*cl+a),
2**(n*cl-n//2*cl+a))).get_matrix()),dense=True)
returnrho_pop

#Ejemplodeuso:
#rho_pop_projected=apply_projection(rho_pop,n,cl,a,projection_method,pre_projection_unitary)

defapply_stage_transform(rho_pop,n,stage,sort0,sort1,mat_sort0,mat_sort1,ancillas,projection_method,pre_projection_unitary,a,cl):
"""
Aplicalatransformacióndeetapaalapoblación.

:paramrho_pop:Poblaciónactual
:paramn:Númerodequbits
:paramstage:Etapaactualdelproceso
:paramsort0:Matrizdeordenamiento0
:paramsort1:Matrizdeordenamiento1
:parammat_sort0:Matrizdeordenamientoparastage%2==0
:parammat_sort1:Matrizdeordenamientoparastage%2==1
:paramancillas:Listadeancillas
:paramprojection_method:Métododeproyecciónautilizar
:parampre_projection_unitary:Matrizunitariaaaplicarantesdelaproyección
:parama:Cantidadaagregaralexponentedelamatrizdeidentidad
:return:Poblacióndespuésdelatransformacióndeetapa
"""
sort=[sort0,sort1][stage%2]
mat_sort=[mat_sort0,mat_sort1][stage%2]
rho_pop=qm.rho(mat_sort.dot(rho_pop.get_matrix()).dot(np.transpose(mat_sort).conjugate()),dense=True)

ifprojection_method!='ptrace':
foraiinancillas:
rho_pop.projection_controlled_rotation(ai,1,qm.rho([1,1],[0,1],[1,0],(2,2)),
pre_projection_unitary,projection_method)
else:
rho_pop=rho_pop.partial_trace(list(range(n*cl)))
rho_pop=qm.rho(np.kron(rho_pop.get_matrix(),
qm.rho([1],[0],[0],(2**a,2**a)).get_matrix()),dense=True)
#Ejemplodeuso:


returnrho_pop
#forstageinrange(0,n):
#rho_pop=apply_stage_transform(rho_pop,n,stage,sort0,sort1,mat_sort0,mat_sort1,ancillas,projection_method,pre_projection_unitary,a)

defquantum_genetic_algorithm(fitness_criteria,fitness_basis=None,init_population=None,n=None,cl=None,generation_number=100,pm=0.01,mutation_pattern=None,mutation_unitary="x",projection_method="r",pre_projection_unitary="I",store_path=None,track_fidelity=None,track_only_reg_states=True):
rho_pop,ancillas,a=init_pop_numpy(init_population,n,cl,generation_number)
iftrack_fidelity:
fidelity_array=np.zeros(shape=(generation_number,5,n,len(track_fidelity)))
ifstore_path:
store=open(store_path,'w')
print('GeneticAlgorithmparameters:',file=store)
print('generation_numbar={:d},pm={:f},populationnumber={:d},chromosomelength={:d}'.format(
generation_number,pm,n,cl),file=store)
print('Trackedfidelityforstates:',file=store)
iftrack_fidelity:
forstateintrack_fidelity:
iftype(state)==qm.rho:
print(state.get_matrix(),file=store)
else:
print(repr(state),file=store)
else:
print("None",file=store)
print(file=store)
mat_clone,mat_cross,sort0,sort1=build_unitary_routines(n,cl,fitness_basis,fitness_criteria,a)
use_mutation_unitary_set,pm_sum,pm_norm,mut_arr,mat_mut_arr=build_mutation_arrays(mutation_unitary,pm,n,cl,mutation_pattern)
ifisinstance(pre_projection_unitary,str):
ifre.match(r"^[iI]$",pre_projection_unitary):
pre_projection_unitary="I"
else:
raiseValueError(f'pre_projection_unitary="{pre_projection_unitary}"notsupported.')
else:
lower_rot_mat=build_pre_projection_rotation(pre_projection_unitary,n,cl,a)
forgenerationinrange(generation_number):
iftrack_fidelity:
forreginrange(n):
reg_state=rho_pop.partial_trace(list(range(reg*cl,(reg+1)*cl)))
fori,stateinenumerate(track_fidelity):
fidelity_array[generation,0,reg,i]=reg_state.fidelity(state)
ifstore_path:
print('-'*32,'\n',
''*9,'Generation:{}'.format(generation),
'\n','-'*32,'\n',
file=store,sep='')

ifnottrack_only_reg_states:
print('initialstate,population+ancillas:\n',repr(rho_pop.store),file=store)
print(file=store)
else:
print('initialstate:',file=store)
forreginrange(n):
print('register{:2d}'.format(reg),end=''*4,file=store)
print(repr(rho_pop.partial_trace(list(range(reg*cl,(reg+1)*cl))).get_matrix()),file=store)
print('\n',file=store)
forstageinrange(0,n):
rho_pop=apply_stage_transform(rho_pop,n,stage,sort0,sort1,sort0,sort1,ancillas,projection_method,pre_projection_unitary,a,cl)
iftrack_fidelity:
forreginrange(n):
reg_state=rho_pop.partial_trace(list(range(reg*cl,(reg+1)*cl)))
fori,stateinenumerate(track_fidelity):
fidelity_array[generation,1,reg,i]=reg_state.fidelity(state)
ifstore_path:
ifnottrack_only_reg_states:
print('sortedstate,population+ancillas:\n',repr(rho_pop.store),file=store)
else:
print('sortedstate:',file=store)
forreginrange(n):
print('register{:2d}'.format(reg),end=''*4,file=store)
print(repr(rho_pop.partial_trace(list(range(reg*cl,(reg+1)*cl))).get_matrix()),file=store)
print('\n',file=store)
print(file=store)
rho_pop=apply_projection(rho_pop,n,cl,a,projection_method,pre_projection_unitary)
iftrack_fidelity:
forreginrange(n):
reg_state=rho_pop.partial_trace(list(range(reg*cl,(reg+1)*cl)))
fori,stateinenumerate(track_fidelity):
fidelity_array[generation,2,reg,i]=reg_state.fidelity(state)
ifstore_path:
ifnottrack_only_reg_states:
print('stateaftersortandclear,population+ancillas:\n',repr(rho_pop.store),file=store)
else:
print('stateaftersortandclear:',file=store)
forreginrange(n):
print('register{:2d}'.format(reg),end=''*4,file=store)
print(repr(rho_pop.partial_trace(list(range(reg*cl,(reg+1)*cl))).get_matrix()),file=store)
print('\n',file=store)
print(file=store)

#4-Crossovertofill
rho_pop=qm.rho(mat_clone.dot(rho_pop.get_matrix()).dot(np.transpose(mat_clone)),dense=True)
rho_pop=qm.rho(mat_cross.dot(rho_pop.get_matrix()).dot(np.transpose(mat_cross)),dense=True)

iftrack_fidelity:
forreginrange(n):
reg_state=rho_pop.partial_trace(list(range(reg*cl,(reg+1)*cl)))
fori,stateinenumerate(track_fidelity):
fidelity_array[generation,3,reg,i]=reg_state.fidelity(state)
ifstore_path:
ifnottrack_only_reg_states:
print('stateaftercrossover,population+ancillas:\n',repr(rho_pop.store),file=store)
else:
print('stateaftercrossover:',file=store)
forreginrange(n):
print('register{:2d}'.format(reg),end=''*4,file=store)
print(repr(rho_pop.partial_trace(list(range(reg*cl,(reg+1)*cl))).get_matrix()),file=store)
print('\n',file=store)
print(file=store)
rho_pop=apply_mutation(rho_pop,n,cl,a,pm_sum,pm_norm,mutation_unitary,pm)

ifstore_path:
store.close()
iftrack_fidelity:
returnrho_pop,fidelity_array
else:
returnrho_pop

#main
defqga_qf_test(fitness_states,samples,dirpath):
"""
NotupdatedtoQGA_QF.
:return:
"""
g=10
n=4
cl=2
pm=[1/n/cl/3]*3
ppu="I"
mu=[np.array([[0,1],[1,0]]),
np.array([[0,-1j],[1j,0]]),
np.array([[1,0],[0,-1]])]
new_dirpath=dirpath

i=1
whileos.path.exists(new_dirpath)andi<1000:
ifdirpath.split("_")[-1].isnumeric():
ifi==1:
i=int(dirpath.split("_")[-1])+1
new_dirpath="_".join(dirpath.split("_")[:-1])+("_%03d"%i)
else:
new_dirpath="_".join(dirpath.split("_")[:-1])+("_%03d"%i)
else:
new_dirpath=dirpath+("_%03d"%i)
i+=1
ifi>1:
print("dirpathcollision,changedto:\n%s"%new_dirpath)
dirpath=new_dirpath
ifnotos.path.exists(dirpath):
os.makedirs(dirpath)
else:
raiseException("dirpathshouldbenew,dirpathcollisionnotcorrected.")

uu=np.zeros((4,4))
fori,stateinenumerate(fitness_states):
uu[:,i]=state
criteria=lambdax,y:sum(int(xi)*2**(len(x)-i-1)fori,xiinenumerate(x))>sum(
int(yi)*2**(len(y)-i-1)fori,yiinenumerate(y))
tf=fitness_states

withopen(dirpath+'/0-Notes','w')asnotes:
notes.write(dirpath+"\n-"*32+"\n"+
"SimulatesQGAwithfitnesscriteriabasedinthissortingorder:\n")
fori,stateinenumerate(fitness_states):
notes.write("%d.\n"%i)
notes.write(repr(state))
notes.write("\n")
notes.write('GeneticAlgorithmparameters:\n')
notes.write('generation_numbar={:d}\npopulationnumber={:d}\nchromosomelength={:d}\n'.format(g,n,cl))
notes.write('pm:\n')
notes.write(repr(pm))
notes.write("\n")
notes.write('pre_projection_unitary:\n')
notes.write(repr(ppu))
notes.write("\n")
notes.write('mutation_unitary:\n')
notes.write(repr(mu))
notes.write("\n")

fortrialinrange(samples):
print("trial",trial,end='')
#t1=time()

rho_population=qm.rho.gen_random_rho(n*cl)

rho_final,ft=quantum_genetic_algorithm(criteria,fitness_basis=uu,
init_population=rho_population,n=n,cl=cl,
generation_number=g,pm=pm,mutation_unitary=mu,
projection_method="ptrace",pre_projection_unitary=ppu,
store_path=None,
track_fidelity=tf)
#print(time()-t1)

withopen(dirpath+'/fidelity_tracks_{:03d}'.format(trial),'w')asfile:
file.write("Trackingfidelitiesfor:\n")
fori,stateinenumerate(fitness_states):
file.write("%d.\n"%i)
file.write(repr(state))
file.write("\n")
file.write("\n")
file.write(repr(ft))


if__name__=='__main__':
fromscipy.statsimportspecial_ortho_group
start_time=time.time()
#state_case_number=600
state_case_number=2
#samples=50
samples=2
run_num=9
dirpath='QGA_QF_run_{:02d}/QGA_BCQO_test_'.format(run_num)

forstate_caseinrange(state_case_number):
print("Statecase:%d"%state_case)
ifstate_case==0:
tf=[np.array([1,0,0,0]),
np.array([0,1,0,0]),
np.array([0,0,1,0]),
np.array([0,0,0,1])]
elifstate_case==1:
tf=[np.full(4,1/2),
np.full(4,1/2)*np.array([1,-1,1,-1]),
np.full(4,1/2)*np.array([1,1,-1,-1]),
np.full(4,1/2)*np.array([1,-1,-1,1])]
else:
#DOESNOTGENERATECOMPLEXNUMBERS!!!
ortho_group=special_ortho_group.rvs(4)
tf=[ortho_group[:,i]foriinrange(4)]

qga_qf_test(fitness_states=tf,samples=samples,dirpath=dirpath+("%03d"%(state_case+1)))
end_time=time.time()
#Calculaeimprimeeltiempodeejecución
execution_time=end_time-start_time
print("Tiempodeejecución:{:.5f}segundos".format(execution_time))